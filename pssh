#!/usr/bin/env perl

use warnings;
use strict;

#use YAML::Syck;
use Data::Dumper;
use YAML::Tiny;

use constant FILE_KNOW_HOSTS => "$ENV{'HOME'}/.ssh/known_hosts";
use constant FILE_PSSH_CONFIG => "$ENV{'HOME'}/.ssh/pssh_config";
use constant STR_SEPARATE => '=' x 60;

use constant SSH_DEFAULT_PORT => 22;

chomp(my $BIN_SSH = `which ssh`);
chomp(my $BIN_MOSH = `which mosh`);
chomp(my $BIN_PING = `which ping`);
chomp(my $BIN_SCP = `which scp`);

#############################################
# parse known_hosts
#############################################

if (! -e FILE_KNOW_HOSTS) {
    print FILE_KNOW_HOSTS, ' not exists, skip.', "\n";
    exit 0;
}

our @sites = ();
&parse_known_hosts();
#my $NUM_CHOICES = @sites;
our $NUM_CHOICES;

#############################################
# read pssh_config
#############################################

our $pssh_config = undef;
our @pssh_menu = ();
our @pssh_noclass_sites = ();

if (-e FILE_PSSH_CONFIG) {
    &config_parse();
}

#############################################
# classify @sites
#############################################

&classify_sites();

#############################################
# main rountine
#############################################

&main();

exit 0;

sub main()
{
    my $error_msg = '';
    my $ret;	# used for save subroutine return value and check

    while (1) {
	&menu_output($error_msg);
	$error_msg = '';

	my $input;
	($ret, $input) = &user_input();
	exit 0 if ($ret != 0);

	my $USE_CMD;
	($USE_CMD, $input) = &parse_cmd($input);

	my ($target_host, $target_port) = ('', '');

	if ($input =~ /^[-+]?\d+$/) {
	    if ($input < 0 or $input > $NUM_CHOICES) {
		$error_msg = 'Selection out of range.';
		next;
	    }
	    ($target_host, $target_port) = &get_target($sites[$input - 1]);
	}
	else {
	    ($target_host, $target_port) = &try_input_match($input);
	    if (!defined($target_host)) {
		$error_msg = 'Cannot find matched item.';
		next;
	    }
	}

	my $c = $USE_CMD;
	$c =~ s,.*/,,;	# basename of CMD

	my @extra_args = ();
	if ($target_port != SSH_DEFAULT_PORT) {
	    if ($c eq 'ssh') {
		push @extra_args, "-p $target_port";
	    }
	    elsif ($c eq 'mosh') {
		push @extra_args, "--ssh=ssh -p $target_port";
	    }
	    elsif ($c eq 'scp') {
		push @extra_args, "-P $target_port";
	    }
	}

	print "Trying connection to \e[36m$target_host\e[m with \e[33m$c\e[m ...\n";
	if ($c eq 'scp') {
	    ($ret, $error_msg) = &spawn_scp($USE_CMD, $target_host, @extra_args);
	    exit 0 unless ($ret != 0);
	    # others go next;
	}
	elsif (@extra_args) {
	    system $USE_CMD, $target_host, @extra_args;
	}
	else {
	    system $USE_CMD, $target_host;
	}
    }
}

#############################################
# sub routine
#############################################

sub user_input($)
{
    my ($code, $input) = (0, undef);

    while (1) {
	print "Please input your selection: ";
	$input = <>;

	if (defined($input)) {
	    chomp($input);
	    last if ($input ne '');
	}
	else {
	    print "\n";
	}
    }

    if ($input =~ /^(q|quit|exit|bye)$/i) {
	print "\e[1;31mbye!\e[m\n";
	$code = 1;
    }

    return ($code, $input);
}

sub parse_cmd($)
{
    my $input = shift @_;
    my $spawn = do {
	if ($input =~ /^(\w+)\s/) {
	    my $cmd = $1;
	    $input =~ s/^$cmd\s+//;

	    if ($cmd =~ /^m(osh)?$/)	{ $BIN_MOSH }
	    #elsif ($cmd =~ /^s(sh)?$/) { $BIN_SSH }
	    elsif ($cmd =~ /^p(ing)?$/) { $BIN_PING }
	    elsif ($cmd =~ /^scp$/)	{ $BIN_SCP }
	    else			{ $BIN_SSH }
	}
	else	{ $BIN_SSH }
    };

    return ($spawn, $input);
}

sub spawn_scp($)
{
    my ($scp_cmd, $remote_host, @extra_args) = @_;
    my $error = undef;

    print "  * Use scp, please provide target >> ";
    my $target = <>;
    chomp $target;

    if ($target =~ /^(-r\s+)/) {
	push @extra_args, '-r';
	$target =~ s/^$1//;
    }

    if ($target =~ /([^ ]+)\s+([^ ]+)$/) {
	my ($src, $dst) = ($1, $2);

	if ($src =~ /^:/ and ! ($dst =~ /^:/)) {
	    $src = "${remote_host}${src}";
	}
	elsif ($dst =~ /^:/ and ! ($src =~ /^:/)) {
	    $dst = "${remote_host}${dst}";
	}
	else {
	    $error = "Error format";
	    return (1, $error);
	}

	if (@extra_args) {
	    system $scp_cmd, @extra_args, $src, $dst
	}
	else {
	    system $scp_cmd, $src, $dst;
	}
	return (0, $error);
    }
}

sub test_fill_class($)
{
    my ($test, $method, $class_name) = @_;

    if ($method eq 'host') {
	foreach my $shash (@sites) {
	    next if (exists($shash->{classes}) and exists($shash->{classes}->{$class_name}));
	    if ($test eq $shash->{host} or $test eq $shash->{ip}) {
		# reference modification
		$shash->{classes}->{$class_name} = 1;
	    }
	}
    }
    elsif ($method eq 'regexp') {
	my $regexp = qr/$test/i;
	foreach my $shash (@sites) {
	    next if (exists($shash->{classes}) and exists($shash->{classes}->{$class_name}));
	    if ($shash->{host} =~ $regexp or $shash->{ip} =~ $regexp) {
		# reference modification
		$shash->{classes}->{$class_name} = 1;
	    }
	}
    }
}

sub classify_sites()
{
    # for readability
    my $pssh_classes = $pssh_config->{classes};

    foreach (@$pssh_classes) {
	next if (!exists($_->{class}));

	my $class_name = $_->{class};

	if (exists($_->{host})) {
	    foreach (@{$_->{host}}) {
		&test_fill_class($_, 'host', $class_name);
	    }
	}

	if (exists($_->{regexp})) {
	    foreach (@{$_->{regexp}}) {
		&test_fill_class($_, 'regexp', $class_name);
	    }
	}

	my @index = grep { exists($sites[$_]->{classes}->{$class_name}) } keys @sites;
	$_->{index} = \@index;
	$_->{count} = scalar @index;
    }

    # collect valid classes
    foreach (keys @$pssh_classes) {
	next if (!exists($pssh_classes->[$_]->{class}) or $pssh_classes->[$_]->{count} == 0);
	#print Dumper($pssh_classes->[$_]);
	push @pssh_menu, $_;
    }

    # collect un-classfied sites
    foreach (keys @sites) {
	next if (%{$sites[$_]->{classes}});
	push @pssh_noclass_sites, $_;
    }

    #print Dumper(@sites);
    #print Dumper($pssh_config);
    #print Dumper(@pssh_menu);
    #print Dumper(@pssh_noclass_sites);
}

sub config_parse()
{
    # pclin.140516:
    #  the primary reason we use list (instead of hash) in classes is,
    #  user can arrange the listing orders as they can see on menu

    # use YAML::Syck
    #$pssh_config = LoadFile(FILE_PSSH_CONFIG);

    # use YAML::Tiny
    $pssh_config = (YAML::Tiny->read(FILE_PSSH_CONFIG))->[0];#->{classes};
#    print Dumper($pssh_config);

#    exit;
    foreach (keys @{$pssh_config->{classes}}) {
	if (!exists($pssh_config->{classes}->[$_]->{class})) {
	    # empty element, but still exists
	    delete $pssh_config->{classes}->[$_];
	}
    }
}

sub parse_known_hosts()
{
    open FR, '<', FILE_KNOW_HOSTS;
    my @c = <FR>;
    close FR;
    chomp(@c);

    foreach (@c) {
	next if /^#/;
	my @hs = split /,/, (split / /)[0];

	my ($host, $ip, $port) = ('', '', SSH_DEFAULT_PORT);
	foreach (@hs) {
	    my $str = $_;
	    if (/\[(.+)\]:(\d+)/)
	    {
		$str = $1;
		$port = $2;
	    }

	    if ($str =~ /(\d+\.){3}\d+/) {
		$ip = $str;
	    }
	    else {
		$host = $str;
	    }
	}
	my %hh = ('host' => $host, 'ip' => $ip, 'port' => $port);
	push @sites, \%hh;
    }
}

sub menu_output($)
{
    my $error = shift @_;

    # for readability
    my $pssh_classes = $pssh_config->{classes};

    system('clear');
    if ($error ne '') {
	print $error, "\n";
    }

    my $i = 0;
    print STR_SEPARATE, "\n";

    foreach (@pssh_menu) {
	$i++;
	printf "[\e[36m%2d\e[m] \e[1;33m%-35s \e[36m[%d]\e[m\n", $i, $pssh_classes->[$_]->{class}, $pssh_classes->[$_]->{count};
    }

    foreach (@pssh_noclass_sites) {
	$i++;
	my $host = $sites[$_]->{'host'};
	$host .= ":$sites[$_]->{'port'}" if ($sites[$_]->{'port'} != SSH_DEFAULT_PORT);
	printf "[\e[36m%2d\e[m] %-36s%s\n", $i, $host, $sites[$_]->{'ip'};
    }

    # reset menu items counting
    $NUM_CHOICES = $i;

    ## pclin.140517:
    ##   maybe put config here: want to see those hosts already have class in 1st level menu?
    #foreach my $site_hash (@sites)
    #{
    #    $i++;
    #    my $host = $site_hash->{'host'};
    #    $host .= ":$site_hash->{'port'}" if ($site_hash->{'port'} != SSH_DEFAULT_PORT);
    #    printf "[\e[36m%2d\e[m] %-36s%s\n", $i, $host, $site_hash->{'ip'};
    #}
    print STR_SEPARATE, "\n";
}

sub get_target($)
{
    my $hash = shift @_;

    my $target = $hash->{'host'};
    $target = $hash->{'ip'} if ($target eq '');

    return ($target, $hash->{'port'});
}

sub try_input_match($)
{
    my $try = shift @_;

    foreach my $site_hash (@sites) {
	if ($site_hash->{'host'} =~ /$try/i) {
	    return &get_target($site_hash);
	}
    }
    return;
}
